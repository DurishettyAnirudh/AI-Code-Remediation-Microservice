cwe: CWE-306
name: Missing Authentication for Critical Function
languages: unspecified
tags: Base, Draft
---
Short Description:
The product does not perform any authentication for functionality that requires a provable
user identity or consumes a significant amount of resources.

Secure Coding Checklist:
Do:
- PHASE:Architecture and Design:Divide the software into anonymous, normal, privileged, and administrative areas. Identify which of these areas require a proven user identity, and use a centralized authentication capability. Identify all potential communication channels, or other means of interaction with the software, to ensure that all channels are appropriately protected, including those channels that are assumed to be accessible only by authorized parties. Developers sometimes perform authentication at the primary channel, but open up a secondary channel that is assumed to be private. For example, a login mechanism may be listening on one network port, but after successful authentication, it may open up a second port where it waits for the connection, but avoids authentication because it assumes that only the authenticated party will connect to the port. In general, if the software or protocol allows a single session or user state to persist across multiple connections or channels, authentication and appropriate credential management need to be used throughout.
- PHASE:Architecture and Design:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.
- PHASE:Architecture and Design:Where possible, avoid implementing custom, grow-your-own authentication routines and consider using authentication capabilities as provided by the surrounding framework, operating system, or environment. These capabilities may avoid common weaknesses that are unique to authentication; support automatic auditing and tracking; and make it easier to provide a clear separation between authentication tasks and authorization tasks. In environments such as the World Wide Web, the line between authentication and authorization is sometimes blurred. If custom authentication routines are required instead of those provided by the server, then these routines must be applied to every single page, since these pages could be requested directly.
- PHASE:Architecture and Design:Libraries or Frameworks:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using libraries with authentication capabilities such as OpenSSL or the ESAPI Authenticator [REF-45].
- PHASE:Implementation System Configuration Operation:When storing data in the cloud (e.g., S3 buckets, Azure blobs, Google Cloud Storage, etc.), use the provider's controls to require strong authentication for users who should be allowed to access the data [REF-1297] [REF-1298] [REF-1302].
Don't:
- Access Control:Other:Avoid situations leading toGain Privileges or Assume Identity:Avoid situations leading toVaries by Context:NOTE:Exposing critical functionality essentially provides an attacker with the privilege level of that functionality. The consequences will depend on the associated functionality, but they can range from reading or modifying sensitive data, accessing administrative or other privileged functionality, or possibly even executing arbitrary code.

Language-Agnostic Guidance:
::METHOD:Manual Analysis:DESCRIPTION:This weakness can be detected using tools and
techniques that require manual (human) analysis, such as penetration testing, threat
modeling, and interactive tools that allow the tester to record and modify an active
session. Specifically, manual static analysis is useful for evaluating the correctness of
custom authentication mechanisms.::METHOD:Automated Static Analysis:DESCRIPTION:Automated
static analysis is useful for detecting commonly-used idioms for authentication. A tool
may be able to analyze related configuration files, such as .htaccess in Apache web
servers, or detect the usage of commonly-used authentication libraries. Generally,
automated static analysis tools have difficulty detecting custom authentication schemes.
In addition, the software's design may include some functionality that is accessible to
any user and does not require an established identity; an automated technique that detects
the absence of authentication may report false
positives.:EFFECTIVENESS:Limited::METHOD:Manual Static Analysis - Binary or
Bytecode:DESCRIPTION:According to SOAR [REF-1479], the following detection techniques may
be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use
manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic
Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR [REF-1479],
the following detection techniques may be useful: Cost effective for partial coverage: Web
Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:SOAR
Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According
to SOAR [REF-1479], the following detection techniques may be useful: Cost effective for
partial coverage: Host Application Interface Scanner Fuzz Tester Framework-based
Fuzzer:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source
Code:DESCRIPTION:According to SOAR [REF-1479], the following detection techniques may be
useful: Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual
analysis of source Manual Source Code Review (not inspections):EFFECTIVENESS:SOAR
Partial::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR
[REF-1479], the following detection techniques may be useful: Cost effective for partial
coverage: Source code Weakness Analyzer Context-configured Source Code Weakness
Analyzer:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design
Review:DESCRIPTION:According to SOAR [REF-1479], the following detection techniques may be
useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements,
design, source code, etc.) Formal Methods / Correct-By-Construction Cost effective for
partial coverage: Attack Modeling:EFFECTIVENESS:High::

::PHASE:Architecture and Design:DESCRIPTION:Divide the software into anonymous, normal,
privileged, and administrative areas. Identify which of these areas require a proven user
identity, and use a centralized authentication capability. Identify all potential
communication channels, or other means of interaction with the software, to ensure that
all channels are appropriately protected, including those channels that are assumed to be
accessible only by authorized parties. Developers sometimes perform authentication at the
primary channel, but open up a secondary channel that is assumed to be private. For
example, a login mechanism may be listening on one network port, but after successful
authentication, it may open up a second port where it waits for the connection, but avoids
authentication because it assumes that only the authenticated party will connect to the
port. In general, if the software or protocol allows a single session or user state to
persist across multiple connections or channels, authentication and appropriate credential
management need to be used throughout.::PHASE:Architecture and Design:DESCRIPTION:For any
security checks that are performed on the client side, ensure that these checks are
duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-
side checks by modifying values after the checks have been performed, or by changing the
client to remove the client-side checks entirely. Then, these modified values would be
submitted to the server.::PHASE:Architecture and Design:DESCRIPTION:Where possible, avoid
implementing custom, grow-your-own authentication routines and consider using
authentication capabilities as provided by the surrounding framework, operating system, or
environment. These capabilities may avoid common weaknesses that are unique to
authentication; support automatic auditing and tracking; and make it easier to provide a
clear separation between authentication tasks and authorization tasks. In environments
such as the World Wide Web, the line between authentication and authorization is sometimes
blurred. If custom authentication routines are required instead of those provided by the
server, then these routines must be applied to every single page, since these pages could
be requested directly.::PHASE:Architecture and Design:STRATEGY:Libraries or
Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness
to occur or provides constructs that make this weakness easier to avoid. For example,
consider using libraries with authentication capabilities such as OpenSSL or the ESAPI
Authenticator [REF-45].::PHASE:Implementation System Configuration
Operation:DESCRIPTION:When storing data in the cloud (e.g., S3 buckets, Azure blobs,
Google Cloud Storage, etc.), use the provider's controls to require strong authentication
for users who should be allowed to access the data [REF-1297] [REF-1298] [REF-1302].::

Sample Fix Idea (Pseudo-code):
```pseudo
# High-level remediation stub
if receives_untrusted_input():
    validate_against_allowlist()
    enforce_least_privilege()
    log_and_monitor()
```
