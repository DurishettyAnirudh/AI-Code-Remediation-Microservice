cwe: CWE-807
name: Reliance on Untrusted Inputs in a Security Decision
languages: unspecified
tags: Base, Incomplete
---
Short Description:
The product uses a protection mechanism that relies on the existence or values of an
input, but the input can be modified by an untrusted actor in a way that bypasses the
protection mechanism.

Secure Coding Checklist:
Do:
- PHASE:Architecture and Design:Attack Surface Reduction:Store state information and sensitive data on the server side only. Ensure that the system definitively and unambiguously keeps track of its own state and user state and has rules defined for legitimate state transitions. Do not allow any application user to affect state directly in any way other than through legitimate actions leading to state transitions. If information must be stored on the client, do not do so without encryption and integrity checking, or otherwise having a mechanism on the server side to catch tampering. Use a message authentication code (MAC) algorithm, such as Hash Message Authentication Code (HMAC) [REF-529]. Apply this against the state or sensitive data that has to be exposed, which can guarantee the integrity of the data - i.e., that the data has not been modified. Ensure that a strong hash function is used (CWE-328).
- PHASE:Architecture and Design:Libraries or Frameworks:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. With a stateless protocol such as HTTP, use a framework that maintains the state for you. Examples include ASP.NET View State [REF-756] and the OWASP ESAPI Session Management feature [REF-45]. Be careful of language features that provide state support, since these might be provided as a convenience to the programmer and may not be considering security.
- PHASE:Architecture and Design:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.
- PHASE:Operation Implementation:Environment Hardening:When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.
- PHASE:Architecture and Design Implementation:Attack Surface Reduction:Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls. Identify all inputs that are used for security decisions and determine if you can modify the design so that you do not have to rely on submitted inputs at all. For example, you may be able to keep critical information about the user's session on the server side instead of recording it within external data.
Don't:
- Confidentiality:Access Control:Availability:Other:Avoid situations leading toBypass Protection Mechanism:Avoid situations leading toGain Privileges or Assume Identity:Avoid situations leading toVaries by Context:NOTE:Attackers can bypass the security decision to access whatever is being protected. The consequences will depend on the associated functionality, but they can range from granting additional privileges to untrusted users to bypassing important security checks. Ultimately, this weakness may lead to exposure or modification of sensitive data, system crash, or execution of arbitrary code.

Language-Agnostic Guidance:
Developers may assume that inputs such as cookies, environment variables, and hidden form
fields cannot be modified. However, an attacker could change these inputs using customized
clients or other attacks. This change might not be detected. When security decisions such
as authentication and authorization are made based on the values of these inputs,
attackers can bypass the security of the software. Without sufficient encryption,
integrity checking, or other mechanism, any input that originates from an outsider cannot
be trusted.

::METHOD:Manual Static Analysis:DESCRIPTION:Since this weakness does not typically appear
frequently within a single software package, manual white box techniques may be able to
provide sufficient code coverage and reduction of false positives if all potentially-
vulnerable operations can be assessed within limited time
constraints.:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Binary or
Bytecode:DESCRIPTION:According to SOAR [REF-1479], the following detection techniques may
be useful: Cost effective for partial coverage: Bytecode Weakness Analysis - including
disassembler + source code weakness analysis Binary Weakness Analysis - including
disassembler + source code weakness analysis:EFFECTIVENESS:SOAR Partial::METHOD:Manual
Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR [REF-1479], the
following detection techniques may be useful: Cost effective for partial coverage: Binary
/ Bytecode disassembler - then use manual analysis for vulnerabilities &
anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Automated Results
Interpretation:DESCRIPTION:According to SOAR [REF-1479], the following detection
techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web
Services Scanner Database Scanners:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis
with Manual Results Interpretation:DESCRIPTION:According to SOAR [REF-1479], the following
detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester
Framework-based Fuzzer Monitored Virtual Environment - run potentially malicious code in
sandbox / wrapper / virtual machine, see if it does anything suspicious:EFFECTIVENESS:SOAR
Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR
[REF-1479], the following detection techniques may be useful: Highly cost effective:
Manual Source Code Review (not inspections):EFFECTIVENESS:High::METHOD:Automated Static
Analysis - Source Code:DESCRIPTION:According to SOAR [REF-1479], the following detection
techniques may be useful: Cost effective for partial coverage: Source code Weakness
Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:SOAR
Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR [REF-1479],
the following detection techniques may be useful: Highly cost effective: Inspection (IEEE
1028 standard) (can apply to requirements, design, source code, etc.) Formal Methods /
Correct-By-Construction Cost effective for partial coverage: Attack
Modeling:EFFECTIVENESS:High::

::PHASE:Architecture and Design:STRATEGY:Attack Surface Reduction:DESCRIPTION:Store state
information and sensitive data on the server side only. Ensure that the system
definitively and unambiguously keeps track of its own state and user state and has rules
defined for legitimate state transitions. Do not allow any application user to affect
state directly in any way other than through legitimate actions leading to state
transitions. If information must be stored on the client, do not do so without encryption
and integrity checking, or otherwise having a mechanism on the server side to catch
tampering. Use a message authentication code (MAC) algorithm, such as Hash Message
Authentication Code (HMAC) [REF-529]. Apply this against the state or sensitive data that
has to be exposed, which can guarantee the integrity of the data - i.e., that the data has
not been modified. Ensure that a strong hash function is used
(CWE-328).::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use
a vetted library or framework that does not allow this weakness to occur or provides
constructs that make this weakness easier to avoid. With a stateless protocol such as
HTTP, use a framework that maintains the state for you. Examples include ASP.NET View
State [REF-756] and the OWASP ESAPI Session Management feature [REF-45]. Be careful of
language features that provide state support, since these might be provided as a
convenience to the programmer and may not be considering security.::PHASE:Architecture and
Design:DESCRIPTION:For any security checks that are performed on the client side, ensure
that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers
can bypass the client-side checks by modifying values after the checks have been
performed, or by changing the client to remove the client-side checks entirely. Then,
these modified values would be submitted to the server.::PHASE:Operation
Implementation:STRATEGY:Environment Hardening:DESCRIPTION:When using PHP, configure the
application so that it does not use register_globals. During implementation, develop the
application so that it does not rely on this feature, but be wary of implementing a
register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and
similar issues.::PHASE:Architecture and Design Implementation:STRATEGY:Attack Surface
Reduction:DESCRIPTION:Understand all the potential areas where untrusted inputs can enter
your software: parameters or arguments, cookies, anything read from the network,
environment variables, reverse DNS lookups, query results, request headers, URL
components, e-mail, files, filenames, databases, and any external systems that provide
data to the application. Remember that such inputs may be obtained indirectly through API
calls. Identify all inputs that are used for security decisions and determine if you can
modify the design so that you do not have to rely on submitted inputs at all. For example,
you may be able to keep critical information about the user's session on the server side
instead of recording it within external data.::

Sample Fix Idea (Pseudo-code):
```pseudo
# High-level remediation stub
if receives_untrusted_input():
    validate_against_allowlist()
    enforce_least_privilege()
    log_and_monitor()
```
