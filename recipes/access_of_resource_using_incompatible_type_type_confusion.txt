cwe: CWE-843
name: Access of Resource Using Incompatible Type ('Type Confusion')
languages: C, C++
tags: Base, Incomplete
---
Short Description:
The product allocates or initializes a resource such as a pointer, object, or variable
using one type, but it later accesses that resource using a type that is incompatible with
the original type.

Secure Coding Checklist:
Do:
- Apply least privilege, validate input, and follow vendor hardening guides.
Don't:
- Availability:Integrity:Confidentiality:Avoid situations leading toRead Memory:Avoid situations leading toModify Memory:Avoid situations leading toExecute Unauthorized Code or Commands:Avoid situations leading toDoS: Crash, Exit, or Restart:NOTE:When a memory buffer is accessed using the wrong type, it could read or write memory out of the bounds of the buffer, if the allocated buffer is smaller than the type that the code is attempting to access, leading to a crash and possibly code execution.

Language-Agnostic Guidance:
When the product accesses the resource using an incompatible type, this could trigger
logical errors because the resource does not have expected properties. In languages
without memory safety, such as C and C++, type confusion can lead to out-of-bounds memory
access. While this weakness is frequently associated with unions when parsing data with
many different embedded object types in C, it can be present in any application that can
interpret the same variable or memory location in multiple ways. This weakness is not
unique to C and C++. For example, errors in PHP applications can be triggered by providing
array parameters when scalars are expected, or vice versa. Languages such as Perl, which
perform automatic conversion of a variable of one type when it is accessed as if it were
another type, can also contain these issues.

Sample Fix Idea (Pseudo-code):
```pseudo
# High-level remediation stub
if receives_untrusted_input():
    validate_against_allowlist()
    enforce_least_privilege()
    log_and_monitor()
```
