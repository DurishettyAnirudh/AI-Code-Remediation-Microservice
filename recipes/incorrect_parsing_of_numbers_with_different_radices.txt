cwe: CWE-1389
name: Incorrect Parsing of Numbers with Different Radices
languages: unspecified
tags: Base, Incomplete
---
Short Description:
The product parses numeric input assuming base 10 (decimal) values, but it does not
account for inputs that use a different base number (radix).

Secure Coding Checklist:
Do:
- PHASE:Implementation:Enforcement by Conversion:If only decimal-based values are expected in the application, conditional checks should be created in a way that prevent octal or hexadecimal strings from being checked. This can be achieved by converting any numerical string to an explicit base-10 integer prior to the conditional check, to prevent octal or hex values from ever being checked against the condition.
- PHASE:Implementation:Input Validation:If various numerical bases do need to be supported, check for leading values indicating the non-decimal base you wish to support (such as 0x for hex) and convert the numeric strings to integers of the respective base. Reject any other alternative-base string that is not intentionally supported by the application.
- PHASE:Implementation:Input Validation:If regular expressions are used to validate IP addresses, ensure that they are bounded using ^ and $ to prevent base-prepended IP addresses from being matched.
Don't:
- Confidentiality:Avoid situations leading toRead Application Data:LIKELIHOOD:Unknown:NOTE:An attacker may use an unexpected numerical base to access private application resources.
- Integrity:Avoid situations leading toBypass Protection Mechanism:Avoid situations leading toAlter Execution Logic:LIKELIHOOD:Unknown:NOTE:An attacker may use an unexpected numerical base to bypass or manipulate access control mechanisms.

Language-Agnostic Guidance:
Frequently, a numeric input that begins with 0 is treated as octal, or 0x causes it to be
treated as hexadecimal, e.g. by the inet_addr() function. For example, 023 (octal) is 35
decimal, or 0x31 is 49 decimal. Other bases may be used as well. If the developer assumes
decimal-only inputs, the code could produce incorrect numbers when the inputs are parsed
using a different base. This can result in unexpected and/or dangerous behavior. For
example, a 0127.0.0.1 IP address is parsed as octal due to the leading 0, whose numeric
value would be the same as 87.0.0.1 (decimal), where the developer likely expected to use
127.0.0.1. The consequences vary depending on the surrounding code in which this weakness
occurs, but they can include bypassing network-based access control using unexpected IP
addresses or netmasks, or causing apparently-symbolic identifiers to be processed as if
they are numbers. In web applications, this can enable bypassing of SSRF restrictions.

::PHASE:Implementation:STRATEGY:Enforcement by Conversion:DESCRIPTION:If only decimal-
based values are expected in the application, conditional checks should be created in a
way that prevent octal or hexadecimal strings from being checked. This can be achieved by
converting any numerical string to an explicit base-10 integer prior to the conditional
check, to prevent octal or hex values from ever being checked against the
condition.::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:If various
numerical bases do need to be supported, check for leading values indicating the non-
decimal base you wish to support (such as 0x for hex) and convert the numeric strings to
integers of the respective base. Reject any other alternative-base string that is not
intentionally supported by the application.::PHASE:Implementation:STRATEGY:Input
Validation:DESCRIPTION:If regular expressions are used to validate IP addresses, ensure
that they are bounded using ^ and $ to prevent base-prepended IP addresses from being
matched.::

Sample Fix Idea (Pseudo-code):
```pseudo
# High-level remediation stub
if receives_untrusted_input():
    validate_against_allowlist()
    enforce_least_privilege()
    log_and_monitor()
```
