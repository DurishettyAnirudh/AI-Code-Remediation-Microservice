cwe: CWE-565
name: Reliance on Cookies without Validation and Integrity Checking
languages: unspecified
tags: Base, Incomplete
---
Short Description:
The product relies on the existence or values of cookies when performing security-critical
operations, but it does not properly ensure that the setting is valid for the associated
user.

Secure Coding Checklist:
Do:
- PHASE:Architecture and Design:Avoid using cookie data for a security-related decision.
- PHASE:Implementation:Perform thorough input validation (i.e.: server side validation) on the cookie data if you're going to use it for a security related decision.
- PHASE:Architecture and Design:Add integrity checks to detect tampering.
- PHASE:Architecture and Design:Protect critical cookies from replay attacks, since cross-site scripting or other attacks may allow attackers to steal a strongly-encrypted cookie that also passes integrity checks. This mitigation applies to cookies that should only be valid during a single transaction or session. By enforcing timeouts, you may limit the scope of an attack. As part of your integrity check, use an unpredictable, server-side value that is not exposed to the client.
Don't:
- Confidentiality:Integrity:Availability:Avoid situations leading toModify Application Data:Avoid situations leading toExecute Unauthorized Code or Commands:NOTE:Attackers can easily modify cookies, within the browser or by implementing the client-side code outside of the browser. Reliance on cookies without detailed validation and integrity checking can allow attackers to bypass authentication, conduct injection attacks such as SQL injection and cross-site scripting, or otherwise modify inputs in unexpected ways.
- Access Control:Avoid situations leading toGain Privileges or Assume Identity:NOTE:It is dangerous to use cookies to set a user's privileges. The cookie can be manipulated to escalate an attacker's privileges to an administrative level.

Language-Agnostic Guidance:
::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis, commonly
referred to as Static Application Security Testing (SAST), can find some instances of this
weakness by analyzing source code (or binary/compiled code) without having to execute it.
Typically, this is done by building a model of data flow and control flow, then searching
for potentially-vulnerable patterns that connect sources (origins of input) with sinks
(destinations where the data interacts with external components, a lower layer such as the
OS, etc.):EFFECTIVENESS:High::

::PHASE:Architecture and Design:DESCRIPTION:Avoid using cookie data for a security-related
decision.::PHASE:Implementation:DESCRIPTION:Perform thorough input validation (i.e.:
server side validation) on the cookie data if you're going to use it for a security
related decision.::PHASE:Architecture and Design:DESCRIPTION:Add integrity checks to
detect tampering.::PHASE:Architecture and Design:DESCRIPTION:Protect critical cookies from
replay attacks, since cross-site scripting or other attacks may allow attackers to steal a
strongly-encrypted cookie that also passes integrity checks. This mitigation applies to
cookies that should only be valid during a single transaction or session. By enforcing
timeouts, you may limit the scope of an attack. As part of your integrity check, use an
unpredictable, server-side value that is not exposed to the client.::

Sample Fix Idea (Pseudo-code):
```pseudo
# High-level remediation stub
if receives_untrusted_input():
    validate_against_allowlist()
    enforce_least_privilege()
    log_and_monitor()
```
