cwe: CWE-170
name: Improper Null Termination
languages: C, C++
tags: Base, Incomplete
---
Short Description:
The product does not terminate or incorrectly terminates a string or array with a null
character or equivalent terminator.

Secure Coding Checklist:
Do:
- PHASE:Requirements:Use a language that is not susceptible to these issues. However, be careful of null byte interaction errors (CWE-626) with lower-level constructs that may be written in a language that is susceptible.
- PHASE:Implementation:Ensure that all string functions used are understood fully as to how they append null characters. Also, be wary of off-by-one errors when appending nulls to the end of strings.
- PHASE:Implementation:If performance constraints permit, special code can be added that validates null-termination of string buffers, this is a rather naive and error-prone solution.
- PHASE:Implementation:Switch to bounded string manipulation functions. Inspect buffer lengths involved in the buffer overrun trace reported with the defect.
- PHASE:Implementation:Add code that fills buffers with nulls (however, the length of buffers still needs to be inspected, to ensure that the non null-terminated string is not written at the physical end of the buffer).
Don't:
- Confidentiality:Integrity:Availability:Avoid situations leading toRead Memory:Avoid situations leading toExecute Unauthorized Code or Commands:NOTE:The case of an omitted null character is the most dangerous of the possible issues. This will almost certainly result in information disclosure, and possibly a buffer overflow condition, which may be exploited to execute arbitrary code.
- Confidentiality:Integrity:Availability:Avoid situations leading toDoS: Crash, Exit, or Restart:Avoid situations leading toRead Memory:Avoid situations leading toDoS: Resource Consumption (CPU):Avoid situations leading toDoS: Resource Consumption (Memory):NOTE:If a null character is omitted from a string, then most string-copying functions will read data until they locate a null character, even outside of the intended boundaries of the string. This could: cause a crash due to a segmentation fault cause sensitive adjacent memory to be copied and sent to an outsider trigger a buffer overflow when the copy is being written to a fixed-size buffer.
- Integrity:Availability:Avoid situations leading toModify Memory:Avoid situations leading toDoS: Crash, Exit, or Restart:NOTE:Misplaced null characters may result in any number of security problems. The biggest issue is a subset of buffer overflow, and write-what-where conditions, where data corruption occurs from the writing of a null character over valid data, or even instructions. A randomly placed null character may put the system into an undefined state, and therefore make it prone to crashing. A misplaced null character may corrupt other data in memory.
- Integrity:Confidentiality:Availability:Access Control:Other:Avoid situations leading toAlter Execution Logic:Avoid situations leading toExecute Unauthorized Code or Commands:NOTE:Should the null character corrupt the process flow, or affect a flag controlling access, it may lead to logical errors which allow for the execution of arbitrary code.

Language-Agnostic Guidance:
Null termination errors frequently occur in two different ways. An off-by-one error could
cause a null to be written out of bounds, leading to an overflow. Or, a program could use
a strncpy() function call incorrectly, which prevents a null terminator from being added
at all. Other scenarios are possible.

::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis, commonly
referred to as Static Application Security Testing (SAST), can find some instances of this
weakness by analyzing source code (or binary/compiled code) without having to execute it.
Typically, this is done by building a model of data flow and control flow, then searching
for potentially-vulnerable patterns that connect sources (origins of input) with sinks
(destinations where the data interacts with external components, a lower layer such as the
OS, etc.):EFFECTIVENESS:High::

::PHASE:Requirements:DESCRIPTION:Use a language that is not susceptible to these issues.
However, be careful of null byte interaction errors (CWE-626) with lower-level constructs
that may be written in a language that is
susceptible.::PHASE:Implementation:DESCRIPTION:Ensure that all string functions used are
understood fully as to how they append null characters. Also, be wary of off-by-one errors
when appending nulls to the end of strings.::PHASE:Implementation:DESCRIPTION:If
performance constraints permit, special code can be added that validates null-termination
of string buffers, this is a rather naive and error-prone
solution.::PHASE:Implementation:DESCRIPTION:Switch to bounded string manipulation
functions. Inspect buffer lengths involved in the buffer overrun trace reported with the
defect.::PHASE:Implementation:DESCRIPTION:Add code that fills buffers with nulls (however,
the length of buffers still needs to be inspected, to ensure that the non null-terminated
string is not written at the physical end of the buffer).::

Sample Fix Idea (Pseudo-code):
```pseudo
# High-level remediation stub
if receives_untrusted_input():
    validate_against_allowlist()
    enforce_least_privilege()
    log_and_monitor()
```
