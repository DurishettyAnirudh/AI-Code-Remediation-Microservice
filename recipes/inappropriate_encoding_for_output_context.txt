cwe: CWE-838
name: Inappropriate Encoding for Output Context
languages: unspecified
tags: Base, Incomplete
---
Short Description:
The product uses or specifies an encoding when generating output to a downstream
component, but the specified encoding is not the same as the encoding that is expected by
the downstream component.

Secure Coding Checklist:
Do:
- PHASE:Implementation:Output Encoding:Use context-aware encoding. That is, understand which encoding is being used by the downstream component, and ensure that this encoding is used. If an encoding can be specified, do so, instead of assuming that the default encoding is the same as the default being assumed by the downstream component.
- PHASE:Architecture and Design:Output Encoding:Where possible, use communications protocols or data formats that provide strict boundaries between control and data. If this is not feasible, ensure that the protocols or formats allow the communicating components to explicitly state which encoding/decoding method is being used. Some template frameworks provide built-in support.
- PHASE:Architecture and Design:Libraries or Frameworks:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using the ESAPI Encoding control [REF-45] or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error. Note that some template mechanisms provide built-in support for the appropriate encoding.
Don't:
- Integrity:Confidentiality:Availability:Avoid situations leading toModify Application Data:Avoid situations leading toExecute Unauthorized Code or Commands:NOTE:An attacker could modify the structure of the message or data being sent to the downstream component, possibly injecting commands.

Language-Agnostic Guidance:
This weakness can cause the downstream component to use a decoding method that produces
different data than what the product intended to send. When the wrong encoding is used -
even if closely related - the downstream component could decode the data incorrectly. This
can have security consequences when the provided boundaries between control and data are
inadvertently broken, because the resulting data could introduce control characters or
special elements that were not sent by the product. The resulting data could then be used
to bypass protection mechanisms such as input validation, and enable injection attacks.
While using output encoding is essential for ensuring that communications between
components are accurate, the use of the wrong encoding - even if closely related - could
cause the downstream component to misinterpret the output. For example, HTML entity
encoding is used for elements in the HTML body of a web page. However, a programmer might
use entity encoding when generating output for that is used within an attribute of an HTML
tag, which could contain functional Javascript that is not affected by the HTML encoding.
While web applications have received the most attention for this problem, this weakness
could potentially apply to any type of product that uses a communications stream that
could support multiple encodings.

::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis, commonly
referred to as Static Application Security Testing (SAST), can find some instances of this
weakness by analyzing source code (or binary/compiled code) without having to execute it.
Typically, this is done by building a model of data flow and control flow, then searching
for potentially-vulnerable patterns that connect sources (origins of input) with sinks
(destinations where the data interacts with external components, a lower layer such as the
OS, etc.):EFFECTIVENESS:High::

::PHASE:Implementation:STRATEGY:Output Encoding:DESCRIPTION:Use context-aware encoding.
That is, understand which encoding is being used by the downstream component, and ensure
that this encoding is used. If an encoding can be specified, do so, instead of assuming
that the default encoding is the same as the default being assumed by the downstream
component.::PHASE:Architecture and Design:STRATEGY:Output Encoding:DESCRIPTION:Where
possible, use communications protocols or data formats that provide strict boundaries
between control and data. If this is not feasible, ensure that the protocols or formats
allow the communicating components to explicitly state which encoding/decoding method is
being used. Some template frameworks provide built-in support.::PHASE:Architecture and
Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that
does not allow this weakness to occur or provides constructs that make this weakness
easier to avoid. For example, consider using the ESAPI Encoding control [REF-45] or a
similar tool, library, or framework. These will help the programmer encode outputs in a
manner less prone to error. Note that some template mechanisms provide built-in support
for the appropriate encoding.::

Sample Fix Idea (Pseudo-code):
```pseudo
# High-level remediation stub
if receives_untrusted_input():
    validate_against_allowlist()
    enforce_least_privilege()
    log_and_monitor()
```
