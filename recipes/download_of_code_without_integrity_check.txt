cwe: CWE-494
name: Download of Code Without Integrity Check
languages: unspecified
tags: Base, Draft
---
Short Description:
The product downloads source code or an executable from a remote location and executes the
code without sufficiently verifying the origin and integrity of the code.

Secure Coding Checklist:
Do:
- PHASE:Implementation:Perform proper forward and reverse DNS lookups to detect DNS spoofing.
- PHASE:Architecture and Design Operation:Encrypt the code with a reliable encryption scheme before transmitting. This will only be a partial solution, since it will not detect DNS spoofing and it will not prevent your code from being modified on the hosting site.
- PHASE:Architecture and Design:Libraries or Frameworks:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid [REF-1482]. Speficially, it may be helpful to use tools or frameworks to perform integrity checking on the transmitted code. When providing the code that is to be downloaded, such as for automatic updates of the software, then use cryptographic signatures for the code and modify the download clients to verify the signatures. Ensure that the implementation does not contain CWE-295, CWE-320, CWE-347, and related weaknesses. Use code signing technologies such as Authenticode. See references [REF-454] [REF-455] [REF-456].
- PHASE:Architecture and Design Operation:Environment Hardening:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.
- PHASE:Architecture and Design Operation:Sandbox or Jail:Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.:EFFECTIVENESS:Limited
Don't:
- Integrity:Availability:Confidentiality:Other:Avoid situations leading toExecute Unauthorized Code or Commands:Avoid situations leading toAlter Execution Logic:Avoid situations leading toOther:NOTE:Executing untrusted code could compromise the control flow of the program. The untrusted code could execute attacker-controlled commands, read or modify sensitive resources, or prevent the software from functioning correctly for legitimate users.

Language-Agnostic Guidance:
An attacker can execute malicious code by compromising the host server, performing DNS
spoofing, or modifying the code in transit.

::METHOD:Manual Analysis:DESCRIPTION:This weakness can be detected using tools and
techniques that require manual (human) analysis, such as penetration testing, threat
modeling, and interactive tools that allow the tester to record and modify an active
session. Specifically, manual static analysis is typically required to find the behavior
that triggers the download of code, and to determine whether integrity-checking methods
are in use.::METHOD:Black Box:DESCRIPTION:Use monitoring tools that examine the software's
process as it interacts with the operating system and the network. This technique is
useful in cases when source code is unavailable, if the software was not developed by you,
or if you want to verify that the build phase did not introduce any new weaknesses.
Examples include debuggers that directly attach to the running process; system-call
tracing utilities such as truss (Solaris) and strace (Linux); system activity monitors
such as FileMon, RegMon, Process Monitor, and other Sysinternals utilities (Windows); and
sniffers and protocol analyzers that monitor network traffic. Attach the monitor to the
process and also sniff the network connection. Trigger features related to product updates
or plugin installation, which is likely to force a code download. Monitor when files are
downloaded and separately executed, or if they are otherwise read back into the process.
Look for evidence of cryptographic library calls that use integrity
checking.::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis,
commonly referred to as Static Application Security Testing (SAST), can find some
instances of this weakness by analyzing source code (or binary/compiled code) without
having to execute it. Typically, this is done by building a model of data flow and control
flow, then searching for potentially-vulnerable patterns that connect sources (origins of
input) with sinks (destinations where the data interacts with external components, a lower
layer such as the OS, etc.):EFFECTIVENESS:High::

::PHASE:Implementation:DESCRIPTION:Perform proper forward and reverse DNS lookups to
detect DNS spoofing.::PHASE:Architecture and Design Operation:DESCRIPTION:Encrypt the code
with a reliable encryption scheme before transmitting. This will only be a partial
solution, since it will not detect DNS spoofing and it will not prevent your code from
being modified on the hosting site.::PHASE:Architecture and Design:STRATEGY:Libraries or
Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness
to occur or provides constructs that make this weakness easier to avoid [REF-1482].
Speficially, it may be helpful to use tools or frameworks to perform integrity checking on
the transmitted code. When providing the code that is to be downloaded, such as for
automatic updates of the software, then use cryptographic signatures for the code and
modify the download clients to verify the signatures. Ensure that the implementation does
not contain CWE-295, CWE-320, CWE-347, and related weaknesses. Use code signing
technologies such as Authenticode. See references [REF-454] [REF-455]
[REF-456].::PHASE:Architecture and Design Operation:STRATEGY:Environment
Hardening:DESCRIPTION:Run your code using the lowest privileges that are required to
accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with
limited privileges that are only used for a single task. That way, a successful attack
will not immediately give the attacker access to the rest of the software or its
environment. For example, database applications rarely need to run as the database
administrator, especially in day-to-day operations.::PHASE:Architecture and Design
Operation:STRATEGY:Sandbox or Jail:DESCRIPTION:Run the code in a jail or similar sandbox
environment that enforces strict boundaries between the process and the operating system.
This may effectively restrict which files can be accessed in a particular directory or
which commands can be executed by the software. OS-level examples include the Unix chroot
jail, AppArmor, and SELinux. In general, managed code may provide some protection. For
example, java.io.FilePermission in the Java SecurityManager allows the software to specify
restrictions on file operations. This may not be a feasible solution, and it only limits
the impact to the operating system; the rest of the application may still be subject to
compromise. Be careful to avoid CWE-243 and other weaknesses related to
jails.:EFFECTIVENESS:Limited::

Sample Fix Idea (Pseudo-code):
```pseudo
# High-level remediation stub
if receives_untrusted_input():
    validate_against_allowlist()
    enforce_least_privilege()
    log_and_monitor()
```
