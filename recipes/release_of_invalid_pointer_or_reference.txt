cwe: CWE-763
name: Release of Invalid Pointer or Reference
languages: C, C++
tags: Base, Incomplete, Memory Management
---
Short Description:
The product attempts to return a memory resource to the system, but it calls the wrong
release function or calls the appropriate release function incorrectly.

Secure Coding Checklist:
Do:
- PHASE:Implementation:Only call matching memory management functions. Do not mix and match routines. For example, when you allocate a buffer with malloc(), dispose of the original pointer with free().
- PHASE:Implementation:When programming in C++, consider using smart pointers provided by the boost library to help correctly and consistently manage memory.
- PHASE:Architecture and Design:Libraries or Frameworks:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, glibc in Linux provides protection against free of invalid pointers.
- PHASE:Architecture and Design:Use a language that provides abstractions for memory allocation and deallocation.
- PHASE:Testing:Use a tool that dynamically detects memory management problems, such as valgrind.
Don't:
- Integrity:Availability:Confidentiality:Avoid situations leading toModify Memory:Avoid situations leading toDoS: Crash, Exit, or Restart:Avoid situations leading toExecute Unauthorized Code or Commands:NOTE:This weakness may result in the corruption of memory, and perhaps instructions, possibly leading to a crash. If the corrupted memory can be effectively controlled, it may be possible to execute arbitrary code.

Language-Agnostic Guidance:
This weakness can take several forms, such as: The memory was allocated, explicitly or
implicitly, via one memory management method and deallocated using a different, non-
compatible function (CWE-762). The function calls or memory management routines chosen are
appropriate, however they are used incorrectly, such as in CWE-761.

::METHOD:Fuzzing:DESCRIPTION:Fuzz testing (fuzzing) is a powerful technique for generating
large numbers of diverse inputs - either randomly or algorithmically - and dynamically
invoking the code with those inputs. Even with random inputs, it is often capable of
generating unexpected results such as crashes, memory corruption, or resource consumption.
Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps
developers to diagnose the issues.:EFFECTIVENESS:High::

::PHASE:Implementation:DESCRIPTION:Only call matching memory management functions. Do not
mix and match routines. For example, when you allocate a buffer with malloc(), dispose of
the original pointer with free().::PHASE:Implementation:DESCRIPTION:When programming in
C++, consider using smart pointers provided by the boost library to help correctly and
consistently manage memory.::PHASE:Architecture and Design:STRATEGY:Libraries or
Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness
to occur or provides constructs that make this weakness easier to avoid. For example,
glibc in Linux provides protection against free of invalid pointers.::PHASE:Architecture
and Design:DESCRIPTION:Use a language that provides abstractions for memory allocation and
deallocation.::PHASE:Testing:DESCRIPTION:Use a tool that dynamically detects memory
management problems, such as valgrind.::

Sample Fix Idea (Pseudo-code):
```pseudo
# High-level remediation stub
if receives_untrusted_input():
    validate_against_allowlist()
    enforce_least_privilege()
    log_and_monitor()
```
