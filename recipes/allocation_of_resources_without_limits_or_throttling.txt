cwe: CWE-770
name: Allocation of Resources Without Limits or Throttling
languages: unspecified
tags: Base, Incomplete
---
Short Description:
The product allocates a reusable resource or group of resources on behalf of an actor
without imposing any intended restrictions on the size or number of resources that can be
allocated.

Secure Coding Checklist:
Do:
- PHASE:Requirements:Clearly specify the minimum and maximum expectations for capabilities, and dictate which behaviors are acceptable when resource allocation reaches limits.
- PHASE:Architecture and Design:Limit the amount of resources that are accessible to unprivileged users. Set per-user limits for resources. Allow the system administrator to define these limits. Be careful to avoid CWE-410.
- PHASE:Architecture and Design:Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place, and it will help the administrator to identify who is committing the abuse. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.
- PHASE:Implementation:Input Validation:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
- PHASE:Architecture and Design:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.
- PHASE:Architecture and Design:Mitigation of resource exhaustion attacks requires that the target system either: recognizes the attack and denies that user further access for a given amount of time, typically by using increasing time delays uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed. The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question. The second solution can be difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply requires more resources on the part of the attacker.
- PHASE:Architecture and Design:Ensure that protocols have specific limits of scale placed on them.
- PHASE:Architecture and Design Implementation:If the program must fail, ensure that it fails gracefully (fails closed). There may be a temptation to simply let the program fail poorly in cases such as low memory conditions, but an attacker may be able to assert control before the software has fully exited. Alternately, an uncontrolled failure could cause cascading problems with other downstream components; for example, the program could send a signal to a downstream process so the process immediately knows that a problem has occurred and has a better chance of recovery. Ensure that all failures in resource allocation place the system into a safe posture.
- PHASE:Operation Architecture and Design:Resource Limitation:Use quotas or other resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems. When the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users. Ensure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703).
Don't:
- Availability:Avoid situations leading toDoS: Resource Consumption (CPU):Avoid situations leading toDoS: Resource Consumption (Memory):Avoid situations leading toDoS: Resource Consumption (Other):NOTE:When allocating resources without limits, an attacker could prevent other systems, applications, or processes from accessing the same type of resource. It can be easy for an attacker to consume many resources by rapidly making many requests or causing larger resources to be used than is needed.

Language-Agnostic Guidance:
::METHOD:Manual Static Analysis:DESCRIPTION:Manual static analysis can be useful for
finding this weakness, but it might not achieve desired code coverage within limited time
constraints. If denial-of-service is not considered a significant risk, or if there is
strong emphasis on consequences such as code execution, then manual analysis may not focus
on this weakness at all.::METHOD:Fuzzing:DESCRIPTION:While fuzzing is typically geared
toward finding low-level implementation bugs, it can inadvertently find uncontrolled
resource allocation problems. This can occur when the fuzzer generates a large number of
test cases but does not restart the targeted product in between test cases. If an
individual test case produces a crash, but it does not do so reliably, then an inability
to limit resource allocation may be the cause. When the allocation is directly affected by
numeric inputs, then fuzzing may produce indications of this
weakness.:EFFECTIVENESS:Opportunistic::METHOD:Automated Dynamic
Analysis:DESCRIPTION:Certain automated dynamic analysis techniques may be effective in
producing side effects of uncontrolled resource allocation problems, especially with
resources such as processes, memory, and connections. The technique may involve generating
a large number of requests to the product within a short time frame. Manual analysis is
likely required to interpret the results.::METHOD:Automated Static
Analysis:DESCRIPTION:Specialized configuration or tuning may be required to train
automated tools to recognize this weakness. Automated static analysis typically has
limited utility in recognizing unlimited allocation problems, except for the missing
release of program-independent system resources such as files, sockets, and processes, or
unchecked arguments to memory. For system resources, automated static analysis may be able
to detect circumstances in which resources are not released after they have expired, or if
too much of a resource is requested at once, as can occur with memory. Automated analysis
of configuration files may be able to detect settings that do not specify a maximum value.
Automated static analysis tools will not be appropriate for detecting exhaustion of custom
resources, such as an intended security policy in which a bulletin board user is only
allowed to make a limited number of posts per day.::

::PHASE:Requirements:DESCRIPTION:Clearly specify the minimum and maximum expectations for
capabilities, and dictate which behaviors are acceptable when resource allocation reaches
limits.::PHASE:Architecture and Design:DESCRIPTION:Limit the amount of resources that are
accessible to unprivileged users. Set per-user limits for resources. Allow the system
administrator to define these limits. Be careful to avoid CWE-410.::PHASE:Architecture and
Design:DESCRIPTION:Design throttling mechanisms into the system architecture. The best
protection is to limit the amount of resources that an unauthorized user can cause to be
expended. A strong authentication and access control model will help prevent such attacks
from occurring in the first place, and it will help the administrator to identify who is
committing the abuse. The login application should be protected against DoS attacks as
much as possible. Limiting the database access, perhaps by caching result sets, can help
minimize the resources expended. To further limit the potential for a DoS attack, consider
tracking the rate of requests received from users and blocking requests that exceed a
defined rate threshold.::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume
all input is malicious. Use an accept known good input validation strategy, i.e., use a
list of acceptable inputs that strictly conform to specifications. Reject any input that
does not strictly conform to specifications, or transform it into something that does.
When performing input validation, consider all potentially relevant properties, including
length, type of input, the full range of acceptable values, missing or extra inputs,
syntax, consistency across related fields, and conformance to business rules. As an
example of business rule logic, boat may be syntactically valid because it only contains
alphanumeric characters, but it is not valid if the input is only expected to contain
colors such as red or blue. Do not rely exclusively on looking for malicious or malformed
inputs. This is likely to miss at least one undesirable input, especially if the code's
environment changes. This can give attackers enough room to bypass the intended
validation. However, denylists can be useful for detecting potential attacks or
determining which inputs are so malformed that they should be rejected
outright.::PHASE:Architecture and Design:DESCRIPTION:For any security checks that are
performed on the client side, ensure that these checks are duplicated on the server side,
in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values
after the checks have been performed, or by changing the client to remove the client-side
checks entirely. Then, these modified values would be submitted to the
server.::PHASE:Architecture and Design:DESCRIPTION:Mitigation of resource exhaustion
attacks requires that the target system either: recognizes the attack and denies that user
further access for a given amount of time, typically by using increasing time delays
uniformly throttles all requests in order to make it more difficult to consume resources
more quickly than they can again be freed. The first of these solutions is an issue in
itself though, since it may allow attackers to prevent the use of the system by a
particular valid user. If the attacker impersonates the valid user, they may be able to
prevent the user from accessing the server in question. The second solution can be
difficult to effectively institute -- and even when properly done, it does not provide a
full solution. It simply requires more resources on the part of the
attacker.::PHASE:Architecture and Design:DESCRIPTION:Ensure that protocols have specific
limits of scale placed on them.::PHASE:Architecture and Design
Implementation:DESCRIPTION:If the program must fail, ensure that it fails gracefully
(fails closed). There may be a temptation to simply let the program fail poorly in cases
such as low memory conditions, but an attacker may be able to assert control before the
software has fully exited. Alternately, an uncontrolled failure could cause cascading
problems with other downstream components; for example, the program could send a signal to
a downstream process so the process immediately knows that a problem has occurred and has
a better chance of recovery. Ensure that all failures in resource allocation place the
system into a safe posture.::PHASE:Operation Architecture and Design:STRATEGY:Resource
Limitation:DESCRIPTION:Use quotas or other resource-limiting settings provided by the
operating system or environment. For example, when managing system resources in POSIX,
setrlimit() can be used to set limits for certain types of resources, and getrlimit() can
determine how many resources are available. However, these functions are not available on
all operating systems. When the current levels get close to the maximum that is defined
for the application (see CWE-770), then limit the allocation of further resources to
privileged users; alternately, begin releasing resources for less-privileged users. While
this mitigation may protect the system from attack, it will not necessarily stop attackers
from adversely impacting other users. Ensure that the application performs the appropriate
error checks and error handling in case resources become unavailable (CWE-703).::

Sample Fix Idea (Pseudo-code):
```pseudo
# High-level remediation stub
if receives_untrusted_input():
    validate_against_allowlist()
    enforce_least_privilege()
    log_and_monitor()
```
