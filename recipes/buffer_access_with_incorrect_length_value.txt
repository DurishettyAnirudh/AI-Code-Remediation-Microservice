cwe: CWE-805
name: Buffer Access with Incorrect Length Value
languages: C, C++
tags: Base, Incomplete, Memory Management
---
Short Description:
The product uses a sequential operation to read or write a buffer, but it uses an
incorrect length value that causes it to access memory that is outside of the bounds of
the buffer.

Secure Coding Checklist:
Do:
- PHASE:Requirements:Language Selection:Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.
- PHASE:Architecture and Design:Libraries or Frameworks:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.
- PHASE:Operation Build and Compilation:Environment Hardening:Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.:EFFECTIVENESS:Defense in Depth
- PHASE:Implementation:Consider adhering to the following rules when allocating and managing an application's memory: Double check that the buffer is as large as specified. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string. Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space. If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.
- PHASE:Architecture and Design:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.
- PHASE:Operation Build and Compilation:Environment Hardening:Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as rebasing (for Windows) and prelinking (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking. For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].:EFFECTIVENESS:Defense in Depth
- PHASE:Operation:Environment Hardening:Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment. For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].:EFFECTIVENESS:Defense in Depth
- PHASE:Architecture and Design Operation:Environment Hardening:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the product or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.
- PHASE:Architecture and Design Operation:Sandbox or Jail:Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.:EFFECTIVENESS:Limited
Don't:
- Integrity:Confidentiality:Availability:Avoid situations leading toRead Memory:Avoid situations leading toModify Memory:Avoid situations leading toExecute Unauthorized Code or Commands:NOTE:Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of a program's implicit security policy. This can often be used to subvert any other security service.
- Availability:Avoid situations leading toModify Memory:Avoid situations leading toDoS: Crash, Exit, or Restart:Avoid situations leading toDoS: Resource Consumption (CPU):NOTE:Buffer overflows generally lead to crashes. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop.

Language-Agnostic Guidance:
When the length value exceeds the size of the destination, a buffer overflow could occur.

::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can often be detected using
automated static analysis tools. Many modern tools use data flow analysis or constraint-
based techniques to minimize the number of false positives. Automated static analysis
generally does not account for environmental considerations when reporting out-of-bounds
memory operations. This can make it difficult for users to determine which warnings should
be investigated first. For example, an analysis tool might report buffer overflows that
originate from command line arguments in a program that is not expected to run with setuid
or other special privileges.:EFFECTIVENESS:High::METHOD:Automated Dynamic
Analysis:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that
interact with the product using large test suites with many diverse inputs, such as fuzz
testing (fuzzing), robustness testing, and fault injection. The product's operation may
slow down, but it should not become unstable, crash, or generate incorrect
results.:EFFECTIVENESS:Moderate::METHOD:Manual Analysis:DESCRIPTION:Manual analysis can be
useful for finding this weakness, but it might not achieve desired code coverage within
limited time constraints. This becomes difficult for weaknesses that must be considered
for all inputs, since the attack surface can be too large.::

::PHASE:Requirements:STRATEGY:Language Selection:DESCRIPTION:Use a language that does not
allow this weakness to occur or provides constructs that make this weakness easier to
avoid. For example, many languages that perform their own memory management, such as Java
and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#,
typically provide overflow protection, but the protection can be disabled by the
programmer. Be wary that a language's interface to native code may still be subject to
overflows, even if the language itself is theoretically safe.::PHASE:Architecture and
Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that
does not allow this weakness to occur or provides constructs that make this weakness
easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega
[REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer
versions of overflow-prone string-handling functions.::PHASE:Operation Build and
Compilation:STRATEGY:Environment Hardening:DESCRIPTION:Use automatic buffer overflow
detection mechanisms that are offered by certain compilers or compiler extensions.
Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC
flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based
detection and range/index checking. D3-SFCV (Stack Frame Canary Validation) from D3FEND
[REF-1334] discusses canary-based detection in detail.:EFFECTIVENESS:Defense in
Depth::PHASE:Implementation:DESCRIPTION:Consider adhering to the following rules when
allocating and managing an application's memory: Double check that the buffer is as large
as specified. When using functions that accept a number of bytes to copy, such as
strncpy(), be aware that if the destination buffer size is equal to the source buffer
size, it may not NULL-terminate the string. Check buffer boundaries if accessing the
buffer in a loop and make sure there is no danger of writing past the allocated space. If
necessary, truncate all input strings to a reasonable length before passing them to the
copy and concatenation functions.::PHASE:Architecture and Design:DESCRIPTION:For any
security checks that are performed on the client side, ensure that these checks are
duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-
side checks by modifying values after the checks have been performed, or by changing the
client to remove the client-side checks entirely. Then, these modified values would be
submitted to the server.::PHASE:Operation Build and Compilation:STRATEGY:Environment
Hardening:DESCRIPTION:Run or compile the software using features or extensions that
randomly arrange the positions of a program's executable and libraries in memory. Because
this makes the addresses unpredictable, it can prevent an attacker from reliably jumping
to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58]
[REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be
similarly realigned if their default memory addresses conflict with other modules, in a
process known as rebasing (for Windows) and prelinking (for Linux) [REF-1332] using
randomly generated addresses. ASLR for libraries cannot be used in conjunction with
prelink since it would require relocating the libraries at run-time, defeating the whole
purpose of prelinking. For more information on these techniques see D3-SAOR (Segment
Address Offset Randomization) from D3FEND [REF-1335].:EFFECTIVENESS:Defense in
Depth::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Use a CPU and operating
system that offers Data Execution Protection (using hardware NX or XD bits) or the
equivalent techniques that simulate this feature in software, such as PaX [REF-60]
[REF-61]. These techniques ensure that any instruction executed is exclusively at a memory
address that is part of the code segment. For more information on these techniques see
D3-PSEP (Process Segment Execution Prevention) from D3FEND
[REF-1336].:EFFECTIVENESS:Defense in Depth::PHASE:Architecture and Design
Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run your code using the lowest
privileges that are required to accomplish the necessary tasks [REF-76]. If possible,
create isolated accounts with limited privileges that are only used for a single task.
That way, a successful attack will not immediately give the attacker access to the rest of
the product or its environment. For example, database applications rarely need to run as
the database administrator, especially in day-to-day operations.::PHASE:Architecture and
Design Operation:STRATEGY:Sandbox or Jail:DESCRIPTION:Run the code in a jail or similar
sandbox environment that enforces strict boundaries between the process and the operating
system. This may effectively restrict which files can be accessed in a particular
directory or which commands can be executed by the software. OS-level examples include the
Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some
protection. For example, java.io.FilePermission in the Java SecurityManager allows the
software to specify restrictions on file operations. This may not be a feasible solution,
and it only limits the impact to the operating system; the rest of the application may
still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related
to jails.:EFFECTIVENESS:Limited::

Sample Fix Idea (Pseudo-code):
```pseudo
# High-level remediation stub
if receives_untrusted_input():
    validate_against_allowlist()
    enforce_least_privilege()
    log_and_monitor()
```
