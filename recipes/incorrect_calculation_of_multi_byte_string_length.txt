cwe: CWE-135
name: Incorrect Calculation of Multi-Byte String Length
languages: C, C++
tags: Base, Draft
---
Short Description:
The product does not correctly calculate the length of strings that can contain wide or
multi-byte characters.

Secure Coding Checklist:
Do:
- PHASE:Implementation:Input Validation:Always verify the length of the string unit character.
- PHASE:Implementation:Libraries or Frameworks:Use length computing functions (e.g. strlen, wcslen, etc.) appropriately with their equivalent type (e.g.: byte, wchar_t, etc.)
Don't:
- Integrity:Confidentiality:Availability:Avoid situations leading toExecute Unauthorized Code or Commands:NOTE:This weakness may lead to a buffer overflow. Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of a program's implicit security policy. This can often be used to subvert any other security service.
- Availability:Confidentiality:Avoid situations leading toRead Memory:Avoid situations leading toDoS: Crash, Exit, or Restart:Avoid situations leading toDoS: Resource Consumption (CPU):Avoid situations leading toDoS: Resource Consumption (Memory):NOTE:Out of bounds memory access will very likely result in the corruption of relevant memory, and perhaps instructions, possibly leading to a crash. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop.
- Confidentiality:Avoid situations leading toRead Memory:NOTE:In the case of an out-of-bounds read, the attacker may have access to sensitive information. If the sensitive information contains system details, such as the current buffer's position in memory, this knowledge can be used to craft further attacks, possibly with more severe consequences.

Language-Agnostic Guidance:
::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis, commonly
referred to as Static Application Security Testing (SAST), can find some instances of this
weakness by analyzing source code (or binary/compiled code) without having to execute it.
Typically, this is done by building a model of data flow and control flow, then searching
for potentially-vulnerable patterns that connect sources (origins of input) with sinks
(destinations where the data interacts with external components, a lower layer such as the
OS, etc.):EFFECTIVENESS:High::

::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Always verify the length of
the string unit character.::PHASE:Implementation:STRATEGY:Libraries or
Frameworks:DESCRIPTION:Use length computing functions (e.g. strlen, wcslen, etc.)
appropriately with their equivalent type (e.g.: byte, wchar_t, etc.)::

Sample Fix Idea (Pseudo-code):
```pseudo
# High-level remediation stub
if receives_untrusted_input():
    validate_against_allowlist()
    enforce_least_privilege()
    log_and_monitor()
```
