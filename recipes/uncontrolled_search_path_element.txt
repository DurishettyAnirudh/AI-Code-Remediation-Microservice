cwe: CWE-427
name: Uncontrolled Search Path Element
languages: unspecified
tags: Base, Code Libraries, Draft, Program Invocation
---
Short Description:
The product uses a fixed or controlled search path to find resources, but one or more
locations in that path can be under the control of unintended actors.

Secure Coding Checklist:
Do:
- PHASE:Architecture and Design Implementation:Attack Surface Reduction:Hard-code the search path to a set of known-safe values (such as system directories), or only allow them to be specified by the administrator in a configuration file. Do not allow these settings to be modified by an external party. Be careful to avoid related weaknesses such as CWE-426 and CWE-428.
- PHASE:Implementation:Attack Surface Reduction:When invoking other programs, specify those programs using fully-qualified pathnames. While this is an effective approach, code that uses fully-qualified pathnames might not be portable to other systems that do not use the same pathnames. The portability can be improved by locating the full-qualified paths in a centralized, easily-modifiable location within the source code, and having the code refer to these paths.
- PHASE:Implementation:Attack Surface Reduction:Remove or restrict all environment settings before invoking other programs. This includes the PATH environment variable, LD_LIBRARY_PATH, and other settings that identify the location of code libraries, and any application-specific search paths.
- PHASE:Implementation:Check your search path before use and remove any elements that are likely to be unsafe, such as the current working directory or a temporary files directory. Since this is a denylist approach, it might not be a complete solution.
- PHASE:Implementation:Use other functions that require explicit paths. Making use of any of the other readily available functions that require explicit paths is a safe way to avoid this problem. For example, system() in C does not require a full path since the shell can take care of finding the program using the PATH environment variable, while execl() and execv() require a full path.
Don't:
- Confidentiality:Integrity:Availability:Avoid situations leading toExecute Unauthorized Code or Commands

Language-Agnostic Guidance:
Although this weakness can occur with any type of resource, it is frequently introduced
when a product uses a directory search path to find executables or code libraries, but the
path contains a directory that can be modified by an attacker, such as /tmp or the current
working directory. In Windows-based systems, when the LoadLibrary or LoadLibraryEx
function is called with a DLL name that does not contain a fully qualified path, the
function follows a search order that includes two path elements that might be
uncontrolled: the directory from which the program has been loaded the current working
directory In some cases, the attack can be conducted remotely, such as when SMB or WebDAV
network shares are used. One or more locations in that path could include the Windows
drive root or its subdirectories. This often exists in Linux-based code assuming the
controlled nature of the root directory (/) or its subdirectories (/etc, etc), or a code
that recursively accesses the parent directory. In Windows, the drive root and some of its
subdirectories have weak permissions by default, which makes them uncontrolled. In some
Unix-based systems, a PATH might be created that contains an empty element, e.g. by
splicing an empty variable into the PATH. This empty element can be interpreted as
equivalent to the current working directory, which might be an untrusted search element.
In software package management frameworks (e.g., npm, RubyGems, or PyPi), the framework
may identify dependencies on third-party libraries or other packages, then consult a
repository that contains the desired package. The framework may search a public repository
before a private repository. This could be exploited by attackers by placing a malicious
package in the public repository that has the same name as a package from the private
repository. The search path might not be directly under control of the developer relying
on the framework, but this search order effectively contains an untrusted element.

::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis, commonly
referred to as Static Application Security Testing (SAST), can find some instances of this
weakness by analyzing source code (or binary/compiled code) without having to execute it.
Typically, this is done by building a model of data flow and control flow, then searching
for potentially-vulnerable patterns that connect sources (origins of input) with sinks
(destinations where the data interacts with external components, a lower layer such as the
OS, etc.):EFFECTIVENESS:High::

::PHASE:Architecture and Design Implementation:STRATEGY:Attack Surface
Reduction:DESCRIPTION:Hard-code the search path to a set of known-safe values (such as
system directories), or only allow them to be specified by the administrator in a
configuration file. Do not allow these settings to be modified by an external party. Be
careful to avoid related weaknesses such as CWE-426 and
CWE-428.::PHASE:Implementation:STRATEGY:Attack Surface Reduction:DESCRIPTION:When invoking
other programs, specify those programs using fully-qualified pathnames. While this is an
effective approach, code that uses fully-qualified pathnames might not be portable to
other systems that do not use the same pathnames. The portability can be improved by
locating the full-qualified paths in a centralized, easily-modifiable location within the
source code, and having the code refer to these
paths.::PHASE:Implementation:STRATEGY:Attack Surface Reduction:DESCRIPTION:Remove or
restrict all environment settings before invoking other programs. This includes the PATH
environment variable, LD_LIBRARY_PATH, and other settings that identify the location of
code libraries, and any application-specific search
paths.::PHASE:Implementation:DESCRIPTION:Check your search path before use and remove any
elements that are likely to be unsafe, such as the current working directory or a
temporary files directory. Since this is a denylist approach, it might not be a complete
solution.::PHASE:Implementation:DESCRIPTION:Use other functions that require explicit
paths. Making use of any of the other readily available functions that require explicit
paths is a safe way to avoid this problem. For example, system() in C does not require a
full path since the shell can take care of finding the program using the PATH environment
variable, while execl() and execv() require a full path.::

Sample Fix Idea (Pseudo-code):
```pseudo
# High-level remediation stub
if receives_untrusted_input():
    validate_against_allowlist()
    enforce_least_privilege()
    log_and_monitor()
```
