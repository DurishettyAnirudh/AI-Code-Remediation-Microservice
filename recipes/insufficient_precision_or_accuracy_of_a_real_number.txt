cwe: CWE-1339
name: Insufficient Precision or Accuracy of a Real Number
languages: unspecified
tags: Base, Draft
---
Short Description:
The product processes a real number with an implementation in which the number's
representation does not preserve required accuracy and precision in its fractional part,
causing an incorrect result.

Secure Coding Checklist:
Do:
- PHASE:Implementation Patching and Maintenance:The developer or maintainer can move to a more accurate representation of real numbers. In extreme cases, the programmer can move to representations such as ratios of BigInts which can represent real numbers to extremely fine precision. The programmer can also use the concept of an Unum real. The memory and CPU tradeoffs of this change must be examined. Since floating point reals are used in many products and many locations, they are implemented in hardware and most format changes will cause the calculations to be moved into software resulting in slower products.
Don't:
- Availability:Avoid situations leading toDoS: Crash, Exit, or Restart:NOTE:This weakness will generally lead to undefined results and therefore crashes. In some implementations the program will halt if the weakness causes an overflow during a calculation.
- Integrity:Avoid situations leading toExecute Unauthorized Code or Commands:NOTE:The results of the math are not as expected. This could cause issues where a value would not be properly calculated and provide an incorrect answer.
- Confidentiality:Availability:Access Control:Avoid situations leading toRead Application Data:Avoid situations leading toModify Application Data:NOTE:This weakness can sometimes trigger buffer overflows which can be used to execute arbitrary code. This is usually outside the scope of a product's implicit security policy.

Language-Agnostic Guidance:
When a security decision or calculation requires highly precise, accurate numbers such as
financial calculations or prices, then small variations in the number could be exploited
by an attacker. There are multiple ways to store the fractional part of a real number in a
computer. In all of these cases, there is a limit to the accuracy of recording a fraction.
If the fraction can be represented in a fixed number of digits (binary or decimal), there
might not be enough digits assigned to represent the number. In other cases the number
cannot be represented in a fixed number of digits due to repeating in decimal or binary
notation (e.g. 0.333333...) or due to a transcendental number such as Π or √2. Rounding of
numbers can lead to situations where the computer results do not adequately match the
result of sufficiently accurate math.

::PHASE:Implementation Patching and Maintenance:DESCRIPTION:The developer or maintainer
can move to a more accurate representation of real numbers. In extreme cases, the
programmer can move to representations such as ratios of BigInts which can represent real
numbers to extremely fine precision. The programmer can also use the concept of an Unum
real. The memory and CPU tradeoffs of this change must be examined. Since floating point
reals are used in many products and many locations, they are implemented in hardware and
most format changes will cause the calculations to be moved into software resulting in
slower products.::

Sample Fix Idea (Pseudo-code):
```pseudo
# High-level remediation stub
if receives_untrusted_input():
    validate_against_allowlist()
    enforce_least_privilege()
    log_and_monitor()
```
