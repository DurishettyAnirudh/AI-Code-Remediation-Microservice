cwe: CWE-89
name: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')
languages: SQL
tags: Base, Stable
---
Short Description:
The product constructs all or part of an SQL command using externally-influenced input
from an upstream component, but it does not neutralize or incorrectly neutralizes special
elements that could modify the intended SQL command when it is sent to a downstream
component. Without sufficient removal or quoting of SQL syntax in user-controllable
inputs, the generated SQL query can cause those inputs to be interpreted as SQL instead of
ordinary user data.

Secure Coding Checklist:
Do:
- PHASE:Architecture and Design:Libraries or Frameworks:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid [REF-1482]. For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.
- PHASE:Architecture and Design:Parameterization:If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated. Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using exec or similar functionality, since this may re-introduce the possibility of SQL injection. [REF-867]
- PHASE:Architecture and Design Operation:Environment Hardening:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations. Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures.
- PHASE:Architecture and Design:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.
- PHASE:Implementation:Output Encoding:While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88). Instead of building a new implementation, such features may be available in the database or programming language. For example, the Oracle DBMS_ASSERT package can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql_real_escape_string() API function is available in both C and PHP.
- PHASE:Implementation:Input Validation:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When constructing SQL query strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping. Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name O'Reilly would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the ' apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded. When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes.
- PHASE:Architecture and Design:Enforcement by Conversion:When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.
- PHASE:Implementation:Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success. If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not. In the context of SQL Injection, error messages revealing the structure of a SQL query can help attackers tailor successful attack strings.
- PHASE:Operation:Firewall:Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth [REF-1481.:EFFECTIVENESS:Moderate
- PHASE:Operation Implementation:Environment Hardening:When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.
Don't:
- Confidentiality:Integrity:Availability:Avoid situations leading toExecute Unauthorized Code or Commands:NOTE:Adversaries could execute system commands, typically by changing the SQL statement to redirect output to a file that can then be executed.
- Confidentiality:Avoid situations leading toRead Application Data:NOTE:Since SQL databases generally hold sensitive data, loss of confidentiality is a frequent problem with SQL injection vulnerabilities.
- Authentication:Avoid situations leading toGain Privileges or Assume Identity:Avoid situations leading toBypass Protection Mechanism:NOTE:If poor SQL commands are used to check user names and passwords or perform other kinds of authentication, it may be possible to connect to the product as another user with no previous knowledge of the password.
- Access Control:Avoid situations leading toBypass Protection Mechanism:NOTE:If authorization information is held in a SQL database, it may be possible to change this information through the successful exploitation of a SQL injection vulnerability.
- Integrity:Avoid situations leading toModify Application Data:NOTE:Just as it may be possible to read sensitive information, it is also possible to modify or even delete this information with a SQL injection attack.

Language-Agnostic Guidance:
::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can often be detected using
automated static analysis tools. Many modern tools use data flow analysis or constraint-
based techniques to minimize the number of false positives. Automated static analysis
might not be able to recognize when proper input validation is being performed, leading to
false positives - i.e., warnings that do not have any security consequences or do not
require any code changes. Automated static analysis might not be able to detect the usage
of custom API functions or third-party libraries that indirectly invoke SQL commands,
leading to false negatives - especially if the API/library code is not available for
analysis.::METHOD:Automated Dynamic Analysis:DESCRIPTION:This weakness can be detected
using dynamic tools and techniques that interact with the software using large test suites
with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault
injection. The software's operation may slow down, but it should not become unstable,
crash, or generate incorrect results.:EFFECTIVENESS:Moderate::METHOD:Manual
Analysis:DESCRIPTION:Manual analysis can be useful for finding this weakness, but it might
not achieve desired code coverage within limited time constraints. This becomes difficult
for weaknesses that must be considered for all inputs, since the attack surface can be too
large.::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to
SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective:
Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary
Weakness Analysis - including disassembler + source code weakness
analysis:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Automated Results
Interpretation:DESCRIPTION:According to SOAR [REF-1479], the following detection
techniques may be useful: Highly cost effective: Database Scanners Cost effective for
partial coverage: Web Application Scanner Web Services
Scanner:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Manual Results
Interpretation:DESCRIPTION:According to SOAR [REF-1479], the following detection
techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based
Fuzzer:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source
Code:DESCRIPTION:According to SOAR [REF-1479], the following detection techniques may be
useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective
for partial coverage: Focused Manual Spotcheck - Focused manual analysis of
source:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source
Code:DESCRIPTION:According to SOAR [REF-1479], the following detection techniques may be
useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source
Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Architecture or Design
Review:DESCRIPTION:According to SOAR [REF-1479], the following detection techniques may be
useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for
partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design,
source code, etc.):EFFECTIVENESS:High::

::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted
library or framework that does not allow this weakness to occur or provides constructs
that make this weakness easier to avoid [REF-1482]. For example, consider using
persistence layers such as Hibernate or Enterprise Java Beans, which can provide
significant protection against SQL injection if used properly.::PHASE:Architecture and
Design:STRATEGY:Parameterization:DESCRIPTION:If available, use structured mechanisms that
automatically enforce the separation between data and code. These mechanisms may be able
to provide the relevant quoting, encoding, and validation automatically, instead of
relying on the developer to provide this capability at every point where output is
generated. Process SQL queries using prepared statements, parameterized queries, or stored
procedures. These features should accept parameters or variables and support strong
typing. Do not dynamically construct and execute query strings within these features using
exec or similar functionality, since this may re-introduce the possibility of SQL
injection. [REF-867]::PHASE:Architecture and Design Operation:STRATEGY:Environment
Hardening:DESCRIPTION:Run your code using the lowest privileges that are required to
accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with
limited privileges that are only used for a single task. That way, a successful attack
will not immediately give the attacker access to the rest of the software or its
environment. For example, database applications rarely need to run as the database
administrator, especially in day-to-day operations. Specifically, follow the principle of
least privilege when creating user accounts to a SQL database. The database users should
only have the minimum privileges necessary to use their account. If the requirements of
the system indicate that a user can read and modify their own data, then limit their
privileges so they cannot read/write others' data. Use the strictest permissions possible
on all database objects, such as execute-only for stored procedures.::PHASE:Architecture
and Design:DESCRIPTION:For any security checks that are performed on the client side,
ensure that these checks are duplicated on the server side, in order to avoid CWE-602.
Attackers can bypass the client-side checks by modifying values after the checks have been
performed, or by changing the client to remove the client-side checks entirely. Then,
these modified values would be submitted to the
server.::PHASE:Implementation:STRATEGY:Output Encoding:DESCRIPTION:While it is risky to
use dynamically-generated query strings, code, or commands that mix control and data
together, sometimes it may be unavoidable. Properly quote arguments and escape any special
characters within those arguments. The most conservative approach is to escape or filter
all characters that do not pass an extremely strict allowlist (such as everything that is
not alphanumeric or white space). If some special characters are still needed, such as
white space, wrap each argument in quotes after the escaping/filtering step. Be careful of
argument injection (CWE-88). Instead of building a new implementation, such features may
be available in the database or programming language. For example, the Oracle DBMS_ASSERT
package can check or enforce that parameters have certain properties that make them less
vulnerable to SQL injection. For MySQL, the mysql_real_escape_string() API function is
available in both C and PHP.::PHASE:Implementation:STRATEGY:Input
Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input
validation strategy, i.e., use a list of acceptable inputs that strictly conform to
specifications. Reject any input that does not strictly conform to specifications, or
transform it into something that does. When performing input validation, consider all
potentially relevant properties, including length, type of input, the full range of
acceptable values, missing or extra inputs, syntax, consistency across related fields, and
conformance to business rules. As an example of business rule logic, boat may be
syntactically valid because it only contains alphanumeric characters, but it is not valid
if the input is only expected to contain colors such as red or blue. Do not rely
exclusively on looking for malicious or malformed inputs. This is likely to miss at least
one undesirable input, especially if the code's environment changes. This can give
attackers enough room to bypass the intended validation. However, denylists can be useful
for detecting potential attacks or determining which inputs are so malformed that they
should be rejected outright. When constructing SQL query strings, use stringent allowlists
that limit the character set based on the expected value of the parameter in the request.
This will indirectly limit the scope of an attack, but this technique is less important
than proper output encoding and escaping. Note that proper output encoding, escaping, and
quoting is the most effective solution for preventing SQL injection, although input
validation may provide some defense-in-depth. This is because it effectively limits what
will appear in output. Input validation will not always prevent SQL injection, especially
if you are required to support free-form text fields that could contain arbitrary
characters. For example, the name O'Reilly would likely pass the validation step, since it
is a common last name in the English language. However, it cannot be directly inserted
into the database because it contains the ' apostrophe character, which would need to be
escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk
of SQL injection, but it would produce incorrect behavior because the wrong name would be
recorded. When feasible, it may be safest to disallow meta-characters entirely, instead of
escaping them. This will provide some defense in depth. After the data is entered into the
database, later processes may neglect to escape meta-characters before use, and you may
not have control over those processes.::PHASE:Architecture and Design:STRATEGY:Enforcement
by Conversion:DESCRIPTION:When the set of acceptable objects, such as filenames or URLs,
is limited or known, create a mapping from a set of fixed input values (such as numeric
IDs) to the actual filenames or URLs, and reject all other
inputs.::PHASE:Implementation:DESCRIPTION:Ensure that error messages only contain minimal
details that are useful to the intended audience and no one else. The messages need to
strike the balance between being too cryptic (which can confuse users) or being too
detailed (which may reveal more than intended). The messages should not reveal the methods
that were used to determine the error. Attackers can use detailed information to refine or
optimize their original attack, thereby increasing their chances of success. If errors
must be captured in some detail, record them in log messages, but consider what could
occur if the log messages can be viewed by attackers. Highly sensitive information such as
passwords should never be saved to log files. Avoid inconsistent messaging that might
accidentally tip off an attacker about internal state, such as whether a user account
exists or not. In the context of SQL Injection, error messages revealing the structure of
a SQL query can help attackers tailor successful attack
strings.::PHASE:Operation:STRATEGY:Firewall:DESCRIPTION:Use an application firewall that
can detect attacks against this weakness. It can be beneficial in cases in which the code
cannot be fixed (because it is controlled by a third party), as an emergency prevention
measure while more comprehensive software assurance measures are applied, or to provide
defense in depth [REF-1481.:EFFECTIVENESS:Moderate::PHASE:Operation
Implementation:STRATEGY:Environment Hardening:DESCRIPTION:When using PHP, configure the
application so that it does not use register_globals. During implementation, develop the
application so that it does not rely on this feature, but be wary of implementing a
register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and
similar issues.::

Sample Fix Idea (Pseudo-code):
```pseudo
# High-level remediation stub
if receives_untrusted_input():
    validate_against_allowlist()
    enforce_least_privilege()
    log_and_monitor()
```
