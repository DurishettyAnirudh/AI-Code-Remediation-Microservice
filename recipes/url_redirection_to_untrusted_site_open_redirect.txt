cwe: CWE-601
name: URL Redirection to Untrusted Site ('Open Redirect')
languages: unspecified
tags: Base, Draft
---
Short Description:
The web application accepts a user-controlled input that specifies a link to an external
site, and uses that link in a redirect.

Secure Coding Checklist:
Do:
- PHASE:Implementation:Input Validation:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. Use a list of approved URLs or domains to be used for redirection.
- PHASE:Architecture and Design:Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving the current site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems (CWE-79) when generating the disclaimer page.
- PHASE:Architecture and Design:Enforcement by Conversion:When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs. For example, ID 1 could map to /login.asp and ID 2 could map to http://www.example.com/. Features such as the ESAPI AccessReferenceMap [REF-45] provide this capability.
- PHASE:Architecture and Design:Ensure that no externally-supplied requests are honored by requiring that all redirect requests include a unique nonce generated by the application [REF-483]. Be sure that the nonce is not predictable (CWE-330).
- PHASE:Architecture and Design Implementation:Attack Surface Reduction:Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls. Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.
- PHASE:Operation:Firewall:Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth [REF-1481].:EFFECTIVENESS:Moderate
Don't:
- Access Control:Avoid situations leading toBypass Protection Mechanism:Avoid situations leading toGain Privileges or Assume Identity:NOTE:The user may be redirected to an untrusted page that contains malware which may then compromise the user's system. In some cases, an open redirect can also enable the immediate download of a file without the user's permission, because the redirection to an external site may lead to endpoints on those sites that automatically trigger a download action (drive-by download [REF-1478]). This will expose the user to extensive risk. The user's interaction with the web server may also be compromised if the malware conducts keylogging or other attacks that steal credentials, personally identifiable information (PII), or other important data.
- Access Control:Confidentiality:Other:Avoid situations leading toBypass Protection Mechanism:Avoid situations leading toGain Privileges or Assume Identity:Avoid situations leading toOther:NOTE:By modifying the URL value to a malicious site, an attacker may successfully launch a phishing scam. The user may be subjected to phishing attacks by being redirected to an untrusted page. The phishing attack may point to an attacker controlled web page that appears to be a trusted web site. The phishers may then steal the user's credentials and then use these credentials to access the legitimate web site. Because the server name in the modified link is identical to the original site, phishing attempts have a more trustworthy appearance.

Language-Agnostic Guidance:
::METHOD:Manual Static Analysis:DESCRIPTION:Since this weakness does not typically appear
frequently within a single software package, manual white box techniques may be able to
provide sufficient code coverage and reduction of false positives if all potentially-
vulnerable operations can be assessed within limited time
constraints.:EFFECTIVENESS:High::METHOD:Automated Dynamic Analysis:DESCRIPTION:Automated
black box tools that supply URLs to every input may be able to spot Location header
modifications, but test case coverage is a factor, and custom redirects may not be
detected.::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis tools
may not be able to determine whether input influences the beginning of a URL, which is
important for reducing false positives.::METHOD:Automated Static
Analysis:DESCRIPTION:Automated static analysis, commonly referred to as Static Application
Security Testing (SAST), can find some instances of this weakness by analyzing source code
(or binary/compiled code) without having to execute it. Typically, this is done by
building a model of data flow and control flow, then searching for potentially-vulnerable
patterns that connect sources (origins of input) with sinks (destinations where the data
interacts with external components, a lower layer such as the OS,
etc.):EFFECTIVENESS:High::METHOD:Automated Static Analysis - Binary or
Bytecode:DESCRIPTION:According to SOAR [REF-1479], the following detection techniques may
be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler +
source code weakness analysis Binary Weakness Analysis - including disassembler + source
code weakness analysis:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Automated Results
Interpretation:DESCRIPTION:According to SOAR [REF-1479], the following detection
techniques may be useful: Highly cost effective: Web Application Scanner Web Services
Scanner Database Scanners:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Manual Results
Interpretation:DESCRIPTION:According to SOAR [REF-1479], the following detection
techniques may be useful: Highly cost effective: Fuzz Tester Framework-based
Fuzzer:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Source
Code:DESCRIPTION:According to SOAR [REF-1479], the following detection techniques may be
useful: Highly cost effective: Manual Source Code Review (not
inspections):EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source
Code:DESCRIPTION:According to SOAR [REF-1479], the following detection techniques may be
useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source
Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Architecture or Design
Review:DESCRIPTION:According to SOAR [REF-1479], the following detection techniques may be
useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for
partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design,
source code, etc.):EFFECTIVENESS:High::

::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is
malicious. Use an accept known good input validation strategy, i.e., use a list of
acceptable inputs that strictly conform to specifications. Reject any input that does not
strictly conform to specifications, or transform it into something that does. When
performing input validation, consider all potentially relevant properties, including
length, type of input, the full range of acceptable values, missing or extra inputs,
syntax, consistency across related fields, and conformance to business rules. As an
example of business rule logic, boat may be syntactically valid because it only contains
alphanumeric characters, but it is not valid if the input is only expected to contain
colors such as red or blue. Do not rely exclusively on looking for malicious or malformed
inputs. This is likely to miss at least one undesirable input, especially if the code's
environment changes. This can give attackers enough room to bypass the intended
validation. However, denylists can be useful for detecting potential attacks or
determining which inputs are so malformed that they should be rejected outright. Use a
list of approved URLs or domains to be used for redirection.::PHASE:Architecture and
Design:DESCRIPTION:Use an intermediate disclaimer page that provides the user with a clear
warning that they are leaving the current site. Implement a long timeout before the
redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems
(CWE-79) when generating the disclaimer page.::PHASE:Architecture and
Design:STRATEGY:Enforcement by Conversion:DESCRIPTION:When the set of acceptable objects,
such as filenames or URLs, is limited or known, create a mapping from a set of fixed input
values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.
For example, ID 1 could map to /login.asp and ID 2 could map to http://www.example.com/.
Features such as the ESAPI AccessReferenceMap [REF-45] provide this
capability.::PHASE:Architecture and Design:DESCRIPTION:Ensure that no externally-supplied
requests are honored by requiring that all redirect requests include a unique nonce
generated by the application [REF-483]. Be sure that the nonce is not predictable
(CWE-330).::PHASE:Architecture and Design Implementation:STRATEGY:Attack Surface
Reduction:DESCRIPTION:Understand all the potential areas where untrusted inputs can enter
your software: parameters or arguments, cookies, anything read from the network,
environment variables, reverse DNS lookups, query results, request headers, URL
components, e-mail, files, filenames, databases, and any external systems that provide
data to the application. Remember that such inputs may be obtained indirectly through API
calls. Many open redirect problems occur because the programmer assumed that certain
inputs could not be modified, such as cookies and hidden form
fields.::PHASE:Operation:STRATEGY:Firewall:DESCRIPTION:Use an application firewall that
can detect attacks against this weakness. It can be beneficial in cases in which the code
cannot be fixed (because it is controlled by a third party), as an emergency prevention
measure while more comprehensive software assurance measures are applied, or to provide
defense in depth [REF-1481].:EFFECTIVENESS:Moderate::

Sample Fix Idea (Pseudo-code):
```pseudo
# High-level remediation stub
if receives_untrusted_input():
    validate_against_allowlist()
    enforce_least_privilege()
    log_and_monitor()
```
