cwe: CWE-788
name: Access of Memory Location After End of Buffer
languages: C, C++
tags: Base, Incomplete, Memory Management
---
Short Description:
The product reads or writes to a buffer using an index or pointer that references a memory
location after the end of the buffer.

Secure Coding Checklist:
Do:
- Apply least privilege, validate input, and follow vendor hardening guides.
Don't:
- Confidentiality:Avoid situations leading toRead Memory:NOTE:For an out-of-bounds read, the attacker may have access to sensitive information. If the sensitive information contains system details, such as the current buffer's position in memory, this knowledge can be used to craft further attacks, possibly with more severe consequences.
- Integrity:Availability:Avoid situations leading toModify Memory:Avoid situations leading toDoS: Crash, Exit, or Restart:NOTE:Out of bounds memory access will very likely result in the corruption of relevant memory, and perhaps instructions, possibly leading to a crash. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop.
- Integrity:Avoid situations leading toModify Memory:Avoid situations leading toExecute Unauthorized Code or Commands:NOTE:If the memory accessible by the attacker can be effectively controlled, it may be possible to execute arbitrary code, as with a standard buffer overflow. If the attacker can overwrite a pointer's worth of memory (usually 32 or 64 bits), they can redirect a function pointer to their own malicious code. Even when the attacker can only modify a single byte arbitrary code execution can be possible. Sometimes this is because the same problem can be exploited repeatedly to the same effect. Other times it is because the attacker can overwrite security-critical application-specific data -- such as a flag indicating whether the user is an administrator.

Language-Agnostic Guidance:
This typically occurs when a pointer or its index is incremented to a position after the
buffer; or when pointer arithmetic results in a position after the buffer.

::METHOD:Fuzzing:DESCRIPTION:Fuzz testing (fuzzing) is a powerful technique for generating
large numbers of diverse inputs - either randomly or algorithmically - and dynamically
invoking the code with those inputs. Even with random inputs, it is often capable of
generating unexpected results such as crashes, memory corruption, or resource consumption.
Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps
developers to diagnose the issues.:EFFECTIVENESS:High::METHOD:Automated Static
Analysis:DESCRIPTION:Automated static analysis, commonly referred to as Static Application
Security Testing (SAST), can find some instances of this weakness by analyzing source code
(or binary/compiled code) without having to execute it. Typically, this is done by
building a model of data flow and control flow, then searching for potentially-vulnerable
patterns that connect sources (origins of input) with sinks (destinations where the data
interacts with external components, a lower layer such as the OS,
etc.):EFFECTIVENESS:High::

Sample Fix Idea (Pseudo-code):
```pseudo
# High-level remediation stub
if receives_untrusted_input():
    validate_against_allowlist()
    enforce_least_privilege()
    log_and_monitor()
```
