cwe: CWE-273
name: Improper Check for Dropped Privileges
languages: unspecified
tags: Base, Incomplete
---
Short Description:
The product attempts to drop privileges but does not check or incorrectly checks to see if
the drop succeeded.

Secure Coding Checklist:
Do:
- PHASE:Architecture and Design:Separation of Privilege:Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.
- PHASE:Implementation:Check the results of all functions that return a value and verify that the value is expected.:EFFECTIVENESS:High
- PHASE:Implementation:In Windows, make sure that the process token has the SeImpersonatePrivilege(Microsoft Server 2003). Code that relies on impersonation for security must ensure that the impersonation succeeded, i.e., that a proper privilege demotion happened.
Don't:
- Access Control:Avoid situations leading toGain Privileges or Assume Identity:NOTE:If privileges are not dropped, neither are access rights of the user. Often these rights can be prevented from being dropped.
- Access Control:Non-Repudiation:Avoid situations leading toGain Privileges or Assume Identity:Avoid situations leading toHide Activities:NOTE:If privileges are not dropped, in some cases the system may record actions as the user which is being impersonated rather than the impersonator.

Language-Agnostic Guidance:
If the drop fails, the product will continue to run with the raised privileges, which
might provide additional access to unprivileged users.

::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis, commonly
referred to as Static Application Security Testing (SAST), can find some instances of this
weakness by analyzing source code (or binary/compiled code) without having to execute it.
Typically, this is done by building a model of data flow and control flow, then searching
for potentially-vulnerable patterns that connect sources (origins of input) with sinks
(destinations where the data interacts with external components, a lower layer such as the
OS, etc.):EFFECTIVENESS:High::

::PHASE:Architecture and Design:STRATEGY:Separation of
Privilege:DESCRIPTION:Compartmentalize the system to have safe areas where trust
boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the
trust boundary and always be careful when interfacing with a compartment outside of the
safe area. Ensure that appropriate compartmentalization is built into the system design,
and the compartmentalization allows for and reinforces privilege separation functionality.
Architects and designers should rely on the principle of least privilege to decide the
appropriate time to use privileges and the time to drop
privileges.::PHASE:Implementation:DESCRIPTION:Check the results of all functions that
return a value and verify that the value is
expected.:EFFECTIVENESS:High::PHASE:Implementation:DESCRIPTION:In Windows, make sure that
the process token has the SeImpersonatePrivilege(Microsoft Server 2003). Code that relies
on impersonation for security must ensure that the impersonation succeeded, i.e., that a
proper privilege demotion happened.::

Sample Fix Idea (Pseudo-code):
```pseudo
# High-level remediation stub
if receives_untrusted_input():
    validate_against_allowlist()
    enforce_least_privilege()
    log_and_monitor()
```
